//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//    Version 1.0; svn revision $LastChangedRevision: 1097 $
//LIC//
//LIC// $LastChangedDate: 2015-12-17 11:53:17 +0000 (Thu, 17 Dec 2015) $
//LIC// 
//LIC// Copyright (C) 2006-2016 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Header file for elements that are used to ...hierher
#ifndef OOMPH_POISSON_SING_FACE_ELEMENTS_HEADER
#define OOMPH_POISSON_SING_FACE_ELEMENTS_HEADER



// hierher uncomment again

/* // Config header generated by autoconfig */
/* #ifdef HAVE_CONFIG_H */
/*   #include <oomph-lib-config.h> */
/* #endif */

/* // oomph-lib includes */
/* #include "../generic/Qelements.h" */

namespace oomph
{


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////


//======================================================================
/// \short Template-free base class for elements that handle singularities
/// in Poisson/Laplace equations. 
//======================================================================
 class TemplateFreeScalableSingularityForPoissonElement : 
  public virtual GeneralisedElement
 {
 
   public:

  /// \short Function pointer to unscaled singular function
  typedef double (*UnscaledSingSolnFctPt)(const Vector<double>& x);

  /// \short Function pointer to gradient of unscaled singular function
  typedef Vector<double> (*GradientOfUnscaledSingSolnFctPt)
   (const Vector<double>& x);


  /// Constructor
  TemplateFreeScalableSingularityForPoissonElement()
   {
    // Internal data to store the unknown amplitude
    add_internal_data(new Data(1));
   }


  /// Pointer to singular unscaled function
  UnscaledSingSolnFctPt& unscaled_singular_fct_pt()
   {
    return Unscaled_singular_fct_pt;
   }

  /// Unscaled singular function
  double unscaled_singular_fct(const Vector<double>& x) const
  {
   if (Unscaled_singular_fct_pt==0)
    {
     return 0.0;
    }
   return Unscaled_singular_fct_pt(x);
  }

  /// Scaled (!) singular function (incl. amplitude!)
  double singular_fct(const Vector<double>& x) const
  {
   return amplitude_of_singular_fct()*unscaled_singular_fct(x);
  }
  


  /// Pointer to gradient of unscaled singular function
  GradientOfUnscaledSingSolnFctPt& gradient_of_unscaled_singular_fct_pt()
   {
    return Gradient_of_unscaled_singular_fct_pt;
   }

  /// Gradient of unscaled singular function
  Vector<double> gradient_of_unscaled_singular_fct(const Vector<double>& x) 
   const
  {
   Vector<double> grad;
   if (Gradient_of_unscaled_singular_fct_pt==0)
    {
     return grad;
    }
   return Gradient_of_unscaled_singular_fct_pt(x);
  }

  /// Gradient of scaled (!) singular function (incl. amplitude!)
  Vector<double> gradient_of_singular_fct(const Vector<double>& x) const
   {
    Vector<double> grad(gradient_of_unscaled_singular_fct(x));
    unsigned n=grad.size();
    for (unsigned i=0;i<n;i++)
     {
      grad[i]*=amplitude_of_singular_fct();
     }
    return grad;
   }
  
  
  /// Access fct for amplitude of sing fct.
  // hierher probably needs to be generalised for 3d
  double amplitude_of_singular_fct() const
  {
   return data_that_stores_amplitude_of_singular_fct()->
    value(index_of_value_that_stores_amplitude_of_singular_fct());
  }

  /// Set amplitude of sing fct.
  // hierher probably needs to be generalised for 3d
  void set_amplitude_of_singular_fct(const double& value)
  {
   data_that_stores_amplitude_of_singular_fct()->
    set_value(index_of_value_that_stores_amplitude_of_singular_fct(),value);
  }



  /// Pin amplitude of singular fct
  // hierher probably needs to be generalised for 3d
  void pin_amplitude_of_singular_fct()
  {
   data_that_stores_amplitude_of_singular_fct()->
    pin(index_of_value_that_stores_amplitude_of_singular_fct());
  }
  
  /// \short Pointer to Data that stores the amplitude of the 
  /// singular fct
  Data* data_that_stores_amplitude_of_singular_fct() const
  {
   return internal_data_pt(0);
  }
  
  /// \short Index to value in Data that stores
  /// the amplitude of the  singular fct
  unsigned index_of_value_that_stores_amplitude_of_singular_fct() const
  {
   return 0;
  }

   private:

  /// Pointer to unscaled singular function
  UnscaledSingSolnFctPt Unscaled_singular_fct_pt;

  /// Pointer to gradient of unscaled singular fct
  GradientOfUnscaledSingSolnFctPt Gradient_of_unscaled_singular_fct_pt;


 };



////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////


//======================================================================
/// \short Class for elements that handle singularities
/// in Poisson/Laplace equations. Templated by bulk element within
/// which we impose regularity on the FE solution by insisting that
/// the slope of the solution at a specified local coordinate, and in
/// in a specified direction is zero. Nodal values of that element
/// become external data for the current element whose equation
/// (zero slope of the FE solution, as discussed) determines the 
/// amplitude of the singular function.
//======================================================================
 template<class REGULARISED_BULK_ELEMENT>
  class ScalableSingularityForPoissonElement : 
  public virtual TemplateFreeScalableSingularityForPoissonElement
 {
 
   public:

  /// Constructor
   ScalableSingularityForPoissonElement() : Regularised_bulk_element_pt(0)
   {}
  
  /// \short Set pointer to bulk element and local coordinate
  /// in it to identify where regularity (zero slope in direction specified
  /// by unit vector n) is imposed on the FE solution
  void specify_regularisation(REGULARISED_BULK_ELEMENT* el_pt,
                              const Vector<double>& s,
                              const Vector<double>& n)
  {
   Regularised_bulk_element_pt=el_pt;
   S_regularisation=s;
   N_regularisation=n;
   // Nodes of element in which slope of solution is forced to be
   // zero act as external data for this element
   // NOTE: We're visiting nodes in their natural order 
   // so the enumeration of the external data with nodes
   // is guaranteed. Should probably police this... 
   unsigned nnod=Regularised_bulk_element_pt->nnode();
   flush_external_data();
   for (unsigned j=0;j<nnod;j++)
    {
     add_external_data(Regularised_bulk_element_pt->node_pt(j));
    }
  }
  
  /// Add the element's contribution to its residual vector
  inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0
   //using a dummy matrix argument
   fill_in_generic_residual_contribution_poisson_sing_fct(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }
  
  /// \short Add the element's contribution to its residual vector and its
  /// Jacobian matrix
   inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                                DenseMatrix<double> &jacobian)
   {
    //Call the generic routine with the flag set to 1
    fill_in_generic_residual_contribution_poisson_sing_fct
     (residuals,jacobian,1);
   }

  
   private:

  /// Add the element's contribution to its residual vector
  inline void fill_in_generic_residual_contribution_poisson_sing_fct(
   Vector<double> &residuals,
   DenseMatrix<double> &jacobian,
   const unsigned& flag)
  {

   if (ndof()==0) return;

#ifdef PARANOID
   if (Regularised_bulk_element_pt==0)
    {
     std::string error_string =
      "Please set up regularisation of FE solution by call to";
     error_string+=" specify_regularisation()\n";
     throw OomphLibError(error_string,
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
   if (S_regularisation.size()!=Regularised_bulk_element_pt->dim())
    {
     std::stringstream error_string;
     error_string << "Size of S_regularisation is "
                  << S_regularisation.size()
                  << " but should be "
                  << Regularised_bulk_element_pt->dim();
     throw OomphLibError(error_string.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
   if (N_regularisation.size()!=Regularised_bulk_element_pt->dim())
    {
     std::stringstream error_string;
     error_string << "Size of N_regularisation is "
                  << N_regularisation.size()
                  << " but should be "
                  << Regularised_bulk_element_pt->dim();
     throw OomphLibError(error_string.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
   // hierher paranoid check null pointers and zero sized vectors 
   int c_local_eqn=internal_local_eqn(0,0);
   if (c_local_eqn>=0)
    {
     // Get flux (=gradient) vector in the bulk element. 
     unsigned n=Regularised_bulk_element_pt->dim();
     Vector<double> grad(n);
     Regularised_bulk_element_pt->get_flux(S_regularisation,grad);
     
     // Work out component in required direction
     double flux=0.0;
     for (unsigned i=0;i<n;i++)
      {
       flux+=grad[i]*N_regularisation[i];
      }

     // Flux should be zero...
     residuals[c_local_eqn]+=flux; 
     if (flag==1)
      {
       // Where does the bulk element store the Poisson FE dofs?
       unsigned u_index=Regularised_bulk_element_pt->u_index_poisson();

       // Derivatives of flux (in bulk element) w.r.t. to nodal unknowns
       // in bulk element
       unsigned nnod_bulk=Regularised_bulk_element_pt->nnode();
       Vector<Vector<double> > dflux_dnodal_u(n); 
       for (unsigned i=0;i<n;i++)
        {
         dflux_dnodal_u[i].resize(nnod_bulk);
        }
       Regularised_bulk_element_pt->get_dflux_dnodal_u(S_regularisation,
                                                       dflux_dnodal_u);

       // Loop over bulk nodes (enumerated in same order as
       // external Data in this element)
       for (unsigned j=0;j<nnod_bulk;j++)
        {
         int local_unknown_u_fe=external_local_eqn(j,u_index);
         if (local_unknown_u_fe>=0)
          {
           double dflux_du=0.0;
           for (unsigned i=0;i<n;i++)
            {
             dflux_du+=dflux_dnodal_u[i][j]*N_regularisation[i];
            }
           jacobian(c_local_eqn,local_unknown_u_fe)+=dflux_du; 
          }
        }
      }

    }
  }

   private:
  
  /// Pointer to bulk element where FE solution is regularised
  REGULARISED_BULK_ELEMENT* Regularised_bulk_element_pt;

  /// \short Local coordinate at which regularisation is imposed on FE 
  /// solution
  Vector<double> S_regularisation;


  /// \short Direction in which slope of FE solution is evaluated 
  /// to regularise FE solution
  Vector<double> N_regularisation;
                              

 };


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//======================================================================
/// \short A class for FaceElements that impose the jump in flux
/// at the interface between regions where a "singular" solution is
/// added to the FE solution and where it's not. The element attaches
/// itself to the faces of the outermost bulk elements in which
/// the singular solution is added. To facilitate the imposition 
/// in the jump in the FE solution, the FaceElement creates a new
/// set of nodes and makes the bulk element point to these. 
///
/// NOTE: Also need to update node pointers of any other bulk elements
///       that are not formally part of this boundary but have isolated
///       nodes on it! Use the existing_duplicate_node_pt map to figure
///       which nodes must be replaced (only for elements in region
///       that contains singularity)
/// 
/// Element retains pointers to the original nodes (which are now only
/// pointed to by the adjacent element in which the singular solution 
/// is not added. Continutity of the solution such that 
/// u_fe + u_sing on the "left" = u_fe on the "right" is enforced
/// by a Lagrange multiplier (stored as additional nodal Data in the
/// FaceElement; the flux is imposed by adding he appropriate contribution
/// to the bulk residual in the element on the "left". 
/// The final complication arises because the amplitude of the
/// "singular" solution is in general an unknown which is handled
/// by a ScalableSingularityForPoissonElement, so we store a pointer to that.
/// The data in that element acts as external Data for the current
/// element.
//======================================================================
 template <class ELEMENT>
  class PoissonWithSingularityFluxJumpFaceElement :
  public virtual FaceGeometry<ELEMENT>, 
  public virtual FaceElement
  {
 
    public:


   /// \short Constructor, takes the pointer to the "bulk" element and the 
   /// index of the face to which the element is attached. 
   /// Map keeps a running count of duplicate nodes already created;
   /// existing_duplicate_node_pt[orig_node_pt]=new_node_pt.
   /// Optional final arg is the identifier for the lagrange multiplier
   PoissonWithSingularityFluxJumpFaceElement(
    FiniteElement* const &bulk_el_pt, 
    const int& face_index,   
    std::map<Node*,Node*>& existing_duplicate_node_pt,
    const unsigned &id=0); 

   ///\short  Broken empty constructor
   PoissonWithSingularityFluxJumpFaceElement()
    {
     std::string error_string = "Don't call empty constructor for ";
     error_string+="PoissonWithSingularityFluxJumpFaceElement";
     throw OomphLibError(error_string,
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   /// Broken copy constructor
   PoissonWithSingularityFluxJumpFaceElement(
    const PoissonWithSingularityFluxJumpFaceElement& dummy) 
    { 
     BrokenCopy::broken_copy("PoissonWithSingularityFluxJumpFaceElement");
    } 
 
   /// Broken assignment operator
   void operator=(const PoissonWithSingularityFluxJumpFaceElement&) 
    {
     BrokenCopy::broken_assign("PoissonWithSingularityFluxJumpFaceElement");
    }

   /// \short Specify the value of nodal zeta from the face geometry
   /// The "global" intrinsic coordinate of the element when
   /// viewed as part of a geometric object should be given by
   /// the FaceElement representation, by default (needed to break
   /// indeterminacy if bulk element is SolidElement)
   double zeta_nodal(const unsigned &n, const unsigned &k,           
                     const unsigned &i) const 
   {return FaceElement::zeta_nodal(n,k,i);}     


   /// Add the element's contribution to its residual vector
   inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
   {
    //Call the generic residuals function with flag set to 0
    //using a dummy matrix argument
    fill_in_generic_residual_contribution_poisson_sing_jump(
     residuals,GeneralisedElement::Dummy_matrix,0);
   }

   /// \short Add the element's contribution to its residual vector and its
   /// Jacobian matrix
   inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                                DenseMatrix<double> &jacobian)
   {
    //Call the generic routine with the flag set to 1
    fill_in_generic_residual_contribution_poisson_sing_jump
     (residuals,jacobian,1);
   }

   /// Output function
   void output(std::ostream &outfile)
   {
    const unsigned n_plot=5;
    output(outfile,n_plot);
   }

   /// \short Output function
   void output(std::ostream &outfile, const unsigned &nplot)
   {
    // Dimension of element 
    unsigned el_dim=dim();
    
    //Vector of local coordinates
    Vector<double> s(el_dim);


    // Number of nodes
    unsigned n_node=nnode();
    Shape psi(n_node);

    // Tecplot header info
    outfile << tecplot_zone_string(nplot);
    
    // Loop over plot points
    unsigned num_plot_points=nplot_points(nplot);
    for (unsigned iplot=0;iplot<num_plot_points;iplot++)
     {
      
      // Get local coordinates/shape fcts at plot point
      get_s_plot(iplot,nplot,s);
      
      shape(s,psi);
      
      //Calculate stuff at integration point
      Vector<double> x(Dim,0.0);
      double u_left=0.0;
      double u_right=0.0;
      double lambda=0.0;
      for(unsigned l=0;l<n_node;l++) 
       {         
        u_left+=this->nodal_value(l,U_index_poisson)*psi[l];
        u_right+=Orig_node_pt[l]->value(U_index_poisson)*psi[l];
        lambda+=this->nodal_value(l,Lambda_index[l])*psi[l];
        for(unsigned i=0;i<Dim;i++)
         {
          x[i] += this->nodal_position(l,i)*psi[l];
         }
       }
      
      for(unsigned i=0;i<Dim;i++) 
       {
        outfile << x[i] << " ";
       }
      outfile << u_left << " " 
              << u_right << " " 
              << u_right-u_left << " " 
              << lambda << " ";
      outfile << std::endl;   
     }
    
    // Write tecplot footer (e.g. FE connectivity lists)
    write_tecplot_zone_footer(outfile,nplot);
    
   }
   
   /// C-style output function -- forward to broken version in FiniteElement
   /// until somebody decides what exactly they want to plot here...
   void output(FILE* file_pt) {FiniteElement::output(file_pt);}

   /// \short C-style output function -- forward to broken version in 
   /// FiniteElement until somebody decides what exactly they want to plot 
   /// here...
   void output(FILE* file_pt, const unsigned &n_plot)
   {FiniteElement::output(file_pt,n_plot);}


   /// Pointer to element that handles singular fct
   ScalableSingularityForPoissonElement<ELEMENT>* poisson_sing_el_pt() const
   {
    return Poisson_sing_el_pt;
   }

   /// \short Set pointer to element that stores singular fct. Data that stores
   /// the amplitude of the singular fct and its index is retrieved from
   /// that element so the Data can be used as external Data in this
   /// element.
   void set_poisson_sing_el_pt(ScalableSingularityForPoissonElement<ELEMENT>* 
                               poisson_sing_el_pt) 
   {
    Poisson_sing_el_pt=poisson_sing_el_pt;
    C_external_data_index=add_external_data(
     poisson_sing_el_pt->data_that_stores_amplitude_of_singular_fct());
    C_external_data_value_index=
     poisson_sing_el_pt->index_of_value_that_stores_amplitude_of_singular_fct();
   }
   
 
   /// Pin Lagrange multipliers and set to zero at specified local node
   void pin_lagrange_multipliers_and_set_to_zero()
   {
    unsigned nnod=nnode();
    for (unsigned j=0;j<nnod;j++)
     {
      node_pt(j)->pin(Lambda_index[j]);
      node_pt(j)->set_value(Lambda_index[j],0.0);
     }
   }
   
    protected:
   
   /// \short Function to compute the shape and test functions and to return 
   /// the Jacobian of mapping between local and global (Eulerian)
   /// coordinates
   inline double shape_and_test(const Vector<double> &s, Shape &psi, 
                                Shape &test)
    const
   {
    //Find number of nodes
    unsigned n_node = nnode();
    
    //Get the shape functions
    shape(s,psi);
    
    //Set the test functions to be the same as the shape functions
    for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

    //Return the value of the jacobian
    return J_eulerian(s);
   }


   /// \short Function to compute the shape and test functions and to return 
   /// the Jacobian of mapping between local and global (Eulerian)
   /// coordinates
   inline double shape_and_test_at_knot(const unsigned &ipt,
                                        Shape &psi, Shape &test)
    const
   {
    //Find number of nodes
    unsigned n_node = nnode();

    //Get the shape functions
    shape_at_knot(ipt,psi);

    //Set the test functions to be the same as the shape functions
    for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

    //Return the value of the jacobian
    return J_eulerian_at_knot(ipt);
   }
 
   
    private:
   

   /// \short Add the element's contribution to its residual vector.
   /// flag=1(or 0): do (or don't) compute the contribution to the
   /// Jacobian as well. 
   void fill_in_generic_residual_contribution_poisson_sing_jump(
    Vector<double> &residuals, DenseMatrix<double> &jacobian, 
    const unsigned& flag);
 
 
   ///The spatial dimension of the problem
   unsigned Dim;

   ///The index at which the unknown is stored at the nodes
   unsigned U_index_poisson;

   /// Vector of pointers to orig nodes
   Vector<Node*> Orig_node_pt;

   /// Pointer to element that handles singular fct
   ScalableSingularityForPoissonElement<ELEMENT>* Poisson_sing_el_pt;

   /// \short Index of external Data that stores the value of the amplitude of
   /// the singular function
   unsigned C_external_data_index;

   /// \short Index of value (within external Data) that stores the
   /// value of the amplitude of the singular function
   unsigned C_external_data_value_index;

   /// Index at which Lagrange multiplier is stored for each node
   Vector<unsigned> Lambda_index;

   // hierher
   Vector<unsigned> External_data_index_for_right_node;

  }; 

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//===========================================================================
/// Constructor, takes the pointer to the "bulk" element, the 
/// index of the fixed local coordinate and its value represented
/// by an integer indicating where the face is located.
/// Map keeps a running count of duplicate nodes already created;
/// existing_duplicate_node_pt[orig_node_pt]=new_node_pt.
/// Optional final arg is the identifier for the lagrange multiplier
//===========================================================================
 template<class ELEMENT>
  PoissonWithSingularityFluxJumpFaceElement<ELEMENT>::
  PoissonWithSingularityFluxJumpFaceElement(
   FiniteElement* const &bulk_el_pt, 
   const int &face_index, 
   std::map<Node*,Node*>& existing_duplicate_node_pt,
   const unsigned& id) : 
 FaceGeometry<ELEMENT>(), FaceElement(), Poisson_sing_el_pt(0),
  C_external_data_index(0), C_external_data_value_index(0)
  { 
   // Let the bulk element build the FaceElement, i.e. setup the pointers 
   // to its nodes (by referring to the appropriate nodes in the bulk
   // element), etc.
   bulk_el_pt->build_face_element(face_index,this);
 
#ifdef PARANOID
   {
    //Check that the element is not a refineable 3d element
    ELEMENT* elem_pt = dynamic_cast<ELEMENT*>(bulk_el_pt);
    //If it's three-d
    if(elem_pt->dim()==3)
     {
      //Is it refineable
      RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(elem_pt);
      if(ref_el_pt!=0)
       {
        if (this->has_hanging_nodes())
         {
          throw OomphLibError(
           "This face element will not work correctly if nodes are hanging\n",
           OOMPH_CURRENT_FUNCTION,
           OOMPH_EXCEPTION_LOCATION);
         }
       }
     }
   }
#endif   

   // Extract the dimension of the problem from the dimension of 
   // the first node
   Dim = this->node_pt(0)->ndim();

   //Set up U_index_poisson. Initialise to zero, which probably won't change
   //in most cases, oh well, the price we pay for generality
   U_index_poisson = 0;

   //Cast to the appropriate PoissonEquation so that we can
   //find the index at which the variable is stored
   //We assume that the dimension of the full problem is the same
   //as the dimension of the node, if this is not the case you will have
   //to write custom elements, sorry
   switch(Dim)
    {
     //One dimensional problem
    case 1:
    {
     PoissonEquations<1>* eqn_pt = 
      dynamic_cast<PoissonEquations<1>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from PoissonEquations.";
       error_string += 
        "Nodes are one dimensional, but cannot cast the bulk element to\n";
       error_string += "PoissonEquations<1>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
     //Otherwise read out the value
     else
      {
       //Read the index from the (cast) bulk element
       U_index_poisson = eqn_pt->u_index_poisson();
      }
    }
    break;
    
    //Two dimensional problem
    case 2:
    {
     PoissonEquations<2>* eqn_pt = 
      dynamic_cast<PoissonEquations<2>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from PoissonEquations.";
       error_string += 
        "Nodes are two dimensional, but cannot cast the bulk element to\n";
       error_string += "PoissonEquations<2>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
     else
      {
       //Read the index from the (cast) bulk element.
       U_index_poisson = eqn_pt->u_index_poisson();
      }
    }
    break;
    
    //Three dimensional problem
    case 3:
    {
     PoissonEquations<3>* eqn_pt = 
      dynamic_cast<PoissonEquations<3>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from PoissonEquations.";
       error_string += 
        "Nodes are three dimensional, but cannot cast the bulk element to\n";
       error_string += "PoissonEquations<3>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
       
      }
     else
      {
       //Read the index from the (cast) bulk element.
       U_index_poisson = eqn_pt->u_index_poisson();
      }
    }
    break;

    //Any other case is an error
    default:
     std::ostringstream error_stream; 
     error_stream <<  "Dimension of node is " << Dim 
                  << ". It should be 1,2, or 3!" << std::endl;
     
     throw OomphLibError(error_stream.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
     break;
    }


   
   // Back up original nodes and make new ones
   unsigned nnod=nnode();
   Orig_node_pt.resize(nnod);
   External_data_index_for_right_node.resize(nnod);
   for (unsigned j=0;j<nnod;j++)
    {
     // Here's the node that used to be shared between the
     // adjacent bulk elements. Note: this may be updated
     // below if it turns out that this bulk node
     // was already replaced.
     Node* nod_pt=node_pt(j);
     Orig_node_pt[j]=nod_pt;
     
     // Find this original node in the map; if we find it
     // it's already been duplicated earlier when creating another
     // FaceElement; in that case use that duplicate rather than
     // creating another one.
     std::map<Node*,Node*>::iterator it=
      existing_duplicate_node_pt.find(nod_pt);

     bool is_replacement=false;
     Node* orig_for_replaced_node_pt=0;
     if (it!=existing_duplicate_node_pt.end())
      {
       // Use the existing duplicate node
       node_pt(j)=(*it).second;
      }
     // Make a new one (as boundary node) hierher update comment when done
     else // @@
      {
       
       // See if it is a replacement (can happen if a very 
       // deformed bulk element has multiple faces on this boundary)
       for (std::map<Node*,Node*>::iterator it=
             existing_duplicate_node_pt.begin();
            it!=existing_duplicate_node_pt.end();it++)
        {
         if ((*it).second==nod_pt)
          {
           is_replacement=true;
           orig_for_replaced_node_pt=(*it).first;
           Orig_node_pt[j]=orig_for_replaced_node_pt;
           break;
          }
        }
       
       // Stick with the existing replacement
       if (is_replacement)
        {
         node_pt(j)=nod_pt;
        }
       // Make new node
       else //--
        {
         unsigned n_dim=nod_pt->ndim();
         unsigned n_position_type=nod_pt->nposition_type();
         unsigned n_value=nod_pt->nvalue();
         node_pt(j)=new BoundaryNode<Node>(n_dim,n_position_type,n_value);
         
         // It has the same coordinate; hierher add history values too
         // when imlementing as Navier Stokes
         for (unsigned i=0;i<n_dim;i++)
          {
           node_pt(j)->x(i)=nod_pt->x(i);
          }
         
         // ...and the same values
         for (unsigned i=0;i<n_value;i++)
          {
           node_pt(j)->set_value(i,nod_pt->value(i));
          }
         
         // It is on the same boundaries
         std::set<unsigned>* boundaries_pt;
         nod_pt->get_boundaries_pt(boundaries_pt);
         for (std::set<unsigned>::iterator it=(*boundaries_pt).begin();
              it!=(*boundaries_pt).end();it++)
          {
           // Get/set boundary ID
           unsigned new_boundary_id=(*it);
           node_pt(j)->add_to_boundary(new_boundary_id);
           
           // Get/set boundary coordinates
           if (nod_pt->boundary_coordinates_have_been_set_up())
            {
             unsigned n=nod_pt->ncoordinates_on_boundary(new_boundary_id);
             Vector<double> boundary_zeta(n);
             nod_pt->get_coordinates_on_boundary(new_boundary_id,
                                                 boundary_zeta);
             node_pt(j)->set_coordinates_on_boundary(new_boundary_id,
                                                     boundary_zeta);
            }
           else
            {
             // hierher throw? (Doesn't happen at the moment, i.e. 
             // when this diagnostic was finally commented out)
             
             /*   oomph_info << "No boundary coordinates have been set up" */
             /*              << " for new local node " << j  */
             /*              << " at : " */
             /*              << node_pt(j)->x(0) << " "  */
             /*              << node_pt(j)->x(1) << " "  */
             /*              << node_pt(j)->x(2) << " "  */
             /*              << std::endl; */
            }
          }
         // Copy across index map for additional values
         std::map<unsigned, unsigned>* index_pt=
          dynamic_cast<BoundaryNodeBase*>(nod_pt)->
          index_of_first_value_assigned_by_face_element_pt();                 
         if (index_pt!=0)
          {
           std::map<unsigned, unsigned>* new_index_pt=
            new std::map<unsigned, unsigned>;
           dynamic_cast<BoundaryNodeBase*>(node_pt(j))->
            index_of_first_value_assigned_by_face_element_pt()=
            new_index_pt;
           for (std::map<unsigned, unsigned>::iterator it=
                 (*index_pt).begin();it!=(*index_pt).end();it++)
            {
             (*new_index_pt)[(*it).first]=(*it).second;
            }
           
          }
         
         // Keep track 
         existing_duplicate_node_pt[nod_pt]=node_pt(j);
         
         // Switch over node for bulk element that we attached ourselves
         // to
         unsigned j_in_bulk=bulk_node_number(j);
         bulk_el_pt->node_pt(j_in_bulk)=node_pt(j);
         
        } // end existing node is already replacement vs make new one
      } 



       // The original node now acts as external data for this element
       // (we still need it to enforce continuity)
     External_data_index_for_right_node[j]=add_external_data(Orig_node_pt[j]);

    }

   // Where is the extra dof representing the Lagrange multiplier stored?
   // Initially store number of values stored right now
   Lambda_index.resize(nnod);
   for (unsigned j=0;j<nnod;j++)
    {
     Lambda_index[j]=node_pt(j)->nvalue();
    }

   // Make space for one Lagrange multiplier at all nodes
   Vector<unsigned> n_additional_values(nnod,1);
   this->add_additional_values(n_additional_values,id);

   // Now check if we've added a new value. If so, that's
   // the Lagrange multiplier; it not, it was already stored
   // there so the actual index is one less
   for (unsigned j=0;j<nnod;j++)
    {
     if (Lambda_index[j]==node_pt(j)->nvalue())
      {
       Lambda_index[j]--;
      }
    }
  }


//===========================================================================
/// Compute the element's residual vector and the Jacobian matrix.
//===========================================================================
 template<class ELEMENT>
  void PoissonWithSingularityFluxJumpFaceElement<ELEMENT>::
  fill_in_generic_residual_contribution_poisson_sing_jump(
   Vector<double> &residuals, DenseMatrix<double> &jacobian, 
   const unsigned& flag)
  {
   
   // hierher this is all for 1D; keep around until DIM-dimensional 
   // version works
   if (this->dim()==0)
    {
     // hierher this is all for 1D; keep around until 
     // DIM-dimensional version works
     
     // Get the various scaled and unscaled singular fcts
     Vector<double> x(1);
     x[0]=node_pt(0)->x(0);
     double u_sing=Poisson_sing_el_pt->singular_fct(x); 
     double unscaled_u_sing=Poisson_sing_el_pt->unscaled_singular_fct(x);
     Vector<double> grad_u_sing=
      Poisson_sing_el_pt->gradient_of_singular_fct(x); 
     Vector<double> unscaled_grad_u_sing=Poisson_sing_el_pt->
      gradient_of_unscaled_singular_fct(x);
     
     // Lagrange multiplier
     double lambda=node_pt(0)->value(Lambda_index[0]);
     
     // Solutions either side of the jump
     double u_left=node_pt(0)->value(0);
     double u_right=Orig_node_pt[0]->value(0);
     
     // Local equation numbers
     int local_eqn_lagr=nodal_local_eqn(0,1);
     int local_eqn_left=nodal_local_eqn(0,0);
     int local_eqn_right=external_local_eqn(0,0); 
     int local_eqn_c=external_local_eqn(C_external_data_index,
                                        C_external_data_value_index);
     
     // Lagrange multiplier equation: Determined from continuity of
     // solution with (scaled!) singular solution on the "left".
     if (local_eqn_lagr>=0)
      {
       residuals[local_eqn_lagr]+=((u_left+u_sing)-u_right); 
       if (flag==1)
        {
         if (local_eqn_left>=0) jacobian(local_eqn_lagr,local_eqn_left)=1.0;
         if (local_eqn_right>=0)jacobian(local_eqn_lagr,local_eqn_right)=-1.0;
         
         // Deriv w.r.t. amplitude is simply the unscaled fct
         if (local_eqn_c>=0)jacobian(local_eqn_lagr,local_eqn_c)=
                             unscaled_u_sing;
        }
      }
     
     
     // Contributions to bulk residual on the "left": Contribution from 
     // Lagrange multiplier and from jump in flux arising from the singular 
     // solution 
     if (local_eqn_left>=0)
      {
       residuals[local_eqn_left]+=lambda+grad_u_sing[0];
       if (flag==1)
        {
         if (local_eqn_lagr>=0) jacobian(local_eqn_left,local_eqn_lagr)+=1.0;
         
         // Deriv w.r.t. amplitude is simply the unscaled fct
         if (local_eqn_c>=0) jacobian(local_eqn_left,local_eqn_c)+=
                              unscaled_grad_u_sing[0];
         
        }
      }
     
     
     // Contribution to bulk residual on the "right" -- Data accessed
     // via external Data in this element.
     if (local_eqn_right>=0)
      {
       residuals[local_eqn_right]-=lambda;
       if (flag==1)
        {
         if (local_eqn_lagr>=0) jacobian(local_eqn_right,local_eqn_lagr)-=1.0;
        }
      }
    }
   else
    {     
     //Find out how many nodes there are
     const unsigned n_node = nnode();
     
     //Set up memory for the shape and test functions
     Shape psi(n_node), test(n_node);
     
     //Set the value of Nintpt
     const unsigned n_intpt = integral_pt()->nweight();
     
     //Set the Vector to hold local coordinates
     Vector<double> s(Dim-1);
     
     //Loop over the integration points
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       
       //Assign values of s
       for(unsigned i=0;i<(Dim-1);i++)
        {
         s[i] = integral_pt()->knot(ipt,i);
        }
       
       //Get the integral weight
       double w = integral_pt()->weight(ipt);
       
       //Find the shape and test functions and return the Jacobian
       //of the mapping
       double J = shape_and_test(s,psi,test);
       
       //Premultiply the weights and the Jacobian
       double W = w*J;
       
       //Calculate stuff at integration point
       Vector<double> interpolated_x(Dim,0.0);
       double u_left=0.0;
       double u_right=0.0;
       double lambda=0.0;
       for(unsigned l=0;l<n_node;l++) 
        {         
         u_left+=this->nodal_value(l,U_index_poisson)*psi[l];
         u_right+=Orig_node_pt[l]->value(U_index_poisson)*psi[l];
         lambda+=this->nodal_value(l,Lambda_index[l])*psi[l];
         for(unsigned i=0;i<Dim;i++)
          {
           interpolated_x[i] += this->nodal_position(l,i)*psi[l];
          }
        }

       // Stuff related to singular fct
       double u_sing=Poisson_sing_el_pt->singular_fct(interpolated_x);  
       double unscaled_u_sing=
        Poisson_sing_el_pt->unscaled_singular_fct(interpolated_x);
       Vector<double> grad_u_sing=
        Poisson_sing_el_pt->gradient_of_singular_fct(interpolated_x);   
       Vector<double> unscaled_grad_u_sing=Poisson_sing_el_pt->
        gradient_of_unscaled_singular_fct(interpolated_x);


       // Compute outer unit normal at the specified local coordinate
       // to compute scaled and unscaled flux of singular solution
       Vector<double> unit_normal(Dim);
       outer_unit_normal(s,unit_normal); 
       double flux_sing=0.0; 
       double unscaled_flux_sing=0.0;
       for(unsigned i=0;i<Dim;i++)
        {
         flux_sing+=unit_normal[i]*grad_u_sing[i];  
         unscaled_flux_sing+=unit_normal[i]*unscaled_grad_u_sing[i];
        }

       //Now add to the appropriate equations
       
       //Loop over the test functions
       for(unsigned l=0;l<n_node;l++)
        {
         // Lagrange multiplier equation: Determined from continuity of
         // solution with (scaled!) singular solution on the "left".
         int local_eqn_lagr=nodal_local_eqn(l,Lambda_index[l]); 
         if (local_eqn_lagr>=0)
          {
           residuals[local_eqn_lagr]+=((u_left+u_sing)-u_right)*test[l]*W;
           if (flag==1)
            {
             for(unsigned l2=0;l2<n_node;l2++)
              {
               
               int local_unknown_left=nodal_local_eqn(l2,U_index_poisson);
               if (local_unknown_left>=0)
                {
                 jacobian(local_eqn_lagr,local_unknown_left)+=psi[l2]*test[l]*W;
                }

               int local_unknown_right=external_local_eqn(
                External_data_index_for_right_node[l2],U_index_poisson);
               if (local_unknown_right>=0)
                {
                 jacobian(local_eqn_lagr,local_unknown_right)-=
                  psi[l2]*test[l]*W;
                }
              }
             
             // Deriv w.r.t. amplitude is simply the unscaled fct
             int local_eqn_c=external_local_eqn(C_external_data_index,
                                                C_external_data_value_index);
             if (local_eqn_c>=0)
              {
               jacobian(local_eqn_lagr,local_eqn_c)+=
                unscaled_u_sing*test[l]*W;      
              }

            }

          }

         // Contribution of Lagrange multiplier and flux to bulk eqn on "left"
         int local_eqn_left=nodal_local_eqn(l,U_index_poisson);
         if (local_eqn_left>=0)
          {
           residuals[local_eqn_left]+=(lambda+flux_sing)*test[l]*W;
           if (flag==1)
            {
             for(unsigned l2=0;l2<n_node;l2++)
              {
               int local_unknown_lambda=nodal_local_eqn(l2,Lambda_index[l2]);
               if (local_unknown_lambda>=0)
                {
                 jacobian(local_eqn_left,local_unknown_lambda)+=
                  psi[l2]*test[l]*W;
                }
              }

             // Deriv w.r.t. amplitude is simply the flux assoc with 
             // unscaled fct
             int local_eqn_c=external_local_eqn(C_external_data_index,
                                                C_external_data_value_index);
             if (local_eqn_c>=0)
              {
               jacobian(local_eqn_left,local_eqn_c)+=
                unscaled_flux_sing*test[l]*W;      
              }

            }
          }
         
         // Contribution of Lagrange multiplier to bulk eqn on "right"
         int local_eqn_right=external_local_eqn
          (External_data_index_for_right_node[l],U_index_poisson); 
         if (local_eqn_right>=0)
          {
           residuals[local_eqn_right]-=lambda*test[l]*W;
           if (flag==1)
            {
             for(unsigned l2=0;l2<n_node;l2++)
              {
               int local_unknown_lambda=nodal_local_eqn(l2,Lambda_index[l2]);
               if (local_unknown_lambda>=0)
                {
                 jacobian(local_eqn_right,local_unknown_lambda)-=
                  psi[l2]*test[l]*W;
                }
              }
            }
          }
        }
      }
    }
  }





///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//======================================================================
/// \short A class for elements that imposes Dirichlet boundary 
/// conditions on complete solution (such that u_fe + C u_sing = u_bc) using a
/// Lagrange multiplier. Thus the element introduce an additional
/// unknown at the nodes it's attached to. C and u_sing are specified
/// via a ScalableSingularityForPoissonElement.
//======================================================================
 template <class ELEMENT>
  class PoissonWithSingularityBCFaceElement : 
  public virtual FaceGeometry<ELEMENT>, 
  public virtual FaceElement 
 {
 
   public:

  /// \short Constructor, takes the pointer to the "bulk" element and the 
  /// index of the face to which the element is attached. Optional final
  /// arg is the identifier for the additional unknowns multiplier
  PoissonWithSingularityBCFaceElement(FiniteElement* const &bulk_el_pt, 
                                    const int& face_index,
                                    const unsigned &id=0); 
  
  ///\short  Broken empty constructor
  PoissonWithSingularityBCFaceElement()
   {
    throw OomphLibError(
     "Don't call empty constructor for PoissonWithSingularityBCFaceElement",
     OOMPH_CURRENT_FUNCTION,
     OOMPH_EXCEPTION_LOCATION);
   }
  
  /// Broken copy constructor
  PoissonWithSingularityBCFaceElement(
   const PoissonWithSingularityBCFaceElement& dummy) 
   { 
    BrokenCopy::broken_copy("PoissonWithSingularityBCFaceElement");
   } 
  
  /// Broken assignment operator
  void operator=(const PoissonWithSingularityBCFaceElement&) 
   {
    BrokenCopy::broken_assign("PoissonWithSingularityBCFaceElement");
   }
  
  /// \short Specify the value of nodal zeta from the face geometry
  /// The "global" intrinsic coordinate of the element when
  /// viewed as part of a geometric object should be given by
  /// the FaceElement representation, by default (needed to break
  /// indeterminacy if bulk element is SolidElement)
  double zeta_nodal(const unsigned &n, const unsigned &k,           
                    const unsigned &i) const 
  {return FaceElement::zeta_nodal(n,k,i);}     


   /// Pointer to element that handles singular fct
   ScalableSingularityForPoissonElement<ELEMENT>* poisson_sing_el_pt() const
   {
    return Poisson_sing_el_pt;
   }

   /// \short Set pointer to element that stores singular fct. Data that stores
   /// the amplitude of the singular fct and its index is retrieved from
   /// that element so the Data can be used as external Data in this
   /// element.
   void set_poisson_sing_el_pt(ScalableSingularityForPoissonElement<ELEMENT>* 
                               poisson_sing_el_pt) 
   {
    Poisson_sing_el_pt=poisson_sing_el_pt;
    C_external_data_index=add_external_data(
     poisson_sing_el_pt->data_that_stores_amplitude_of_singular_fct());
    C_external_data_value_index=
     poisson_sing_el_pt->index_of_value_that_stores_amplitude_of_singular_fct();
   }


  /// Add the element's contribution to its residual vector
  inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0
   //using a dummy matrix argument
   fill_in_generic_residual_contribution_poisson_sing(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }


  /// \short Add the element's contribution to its residual vector and its
  /// Jacobian matrix
  inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                               DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_poisson_sing(residuals,jacobian,1);
  }

  /// Output function
  void output(std::ostream &outfile)
  {
   const unsigned n_plot=5;
   output(outfile,n_plot);
  }

  /// \short Output function
  void output(std::ostream &outfile, const unsigned &nplot)
  {
   //oomph_info << "hierher need to update output fct" << std::endl;
   return;
  }

  /// \short Provide nodal values of desired boundary values.
  /// They're imposed by Lagrange multipliers.
  void set_nodal_boundary_values(const Vector<double>& nodal_boundary_value)
  {
#ifdef PARANOID
   if (nodal_boundary_value.size()!=nnode())
    {
     std::stringstream error;
     error << "nodel_boundary_value is a vector of size " 
           << nodal_boundary_value.size() 
           << " but should have the same size as the number of nodes, "
           << nnode();
     throw OomphLibError(error.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   Nodal_boundary_value=nodal_boundary_value;
  }

  /// Pin Lagrange multiplier at specified local node
  void pin_lagrange_multiplier_at_specified_local_node(const unsigned& j)
  {
   node_pt(j)->pin(Lambda_index[j]);
  }

  /// Unpin FE part of the solution at specified local node
  void unpin_u_fe_at_specified_local_node(const unsigned&j )
  {   
   node_pt(j)->unpin(U_index_poisson);
  }

  /// C-style output function -- forward to broken version in FiniteElement
  /// until somebody decides what exactly they want to plot here...
  void output(FILE* file_pt) {FiniteElement::output(file_pt);}

  /// \short C-style output function -- forward to broken version in 
  /// FiniteElement until somebody decides what exactly they want to plot 
  /// here...
  void output(FILE* file_pt, const unsigned &n_plot)
  {FiniteElement::output(file_pt,n_plot);}


   protected:

  /// \short Function to compute the shape and test functions and to return 
  /// the Jacobian of mapping between local and global (Eulerian)
  /// coordinates
  inline double shape_and_test(const Vector<double> &s, Shape &psi, Shape &test)
   const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the shape functions
   shape(s,psi);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

   //Return the value of the jacobian
   return J_eulerian(s);
  }


  /// \short Function to compute the shape and test functions and to return 
  /// the Jacobian of mapping between local and global (Eulerian)
  /// coordinates
  inline double shape_and_test_at_knot(const unsigned &ipt,
                                       Shape &psi, Shape &test)
   const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the shape functions
   shape_at_knot(ipt,psi);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

   //Return the value of the jacobian
   return J_eulerian_at_knot(ipt);
  }


   private:


  /// \short Add the element's contribution to its residual vector.
  /// flag=1(or 0): do (or don't) compute the contribution to the
  /// Jacobian as well. 
  void fill_in_generic_residual_contribution_poisson_sing(
   Vector<double> &residuals, DenseMatrix<double> &jacobian, 
   const unsigned& flag);
 
 
  ///The spatial dimension of the problem
  unsigned Dim;

  ///The index at which the Poisson unknown is stored at the nodes
  unsigned U_index_poisson;

  /// \short The index at which the Lagrange multiplier that enforces
  /// the Dirichlet BC is stored at the nodes
  Vector<unsigned> Lambda_index;

  /// Desired boundary values at nodes
  Vector<double> Nodal_boundary_value;

  /// \short Index of external Data that stores the value of the amplitude of
  /// the singular function
  unsigned C_external_data_index;
  
  /// \short Index of value (within external Data) that stores the
  /// value of the amplitude of the singular function
  unsigned C_external_data_value_index;
  
  /// \short Pointer to element that stores pointer to singular fct 
  /// (and its gradients etc.) as well as amplitude
  ScalableSingularityForPoissonElement<ELEMENT>* Poisson_sing_el_pt;

 }; 

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//===========================================================================
/// Constructor, takes the pointer to the "bulk" element, the 
/// index of the fixed local coordinate and its value represented
/// by an integer indicating which face we're on.
/// Optional final arg is the identifier for the new values created
/// by this face element
//===========================================================================
 template<class ELEMENT>
  PoissonWithSingularityBCFaceElement<ELEMENT>::
  PoissonWithSingularityBCFaceElement(FiniteElement* const &bulk_el_pt, 
                                    const int &face_index, 
                                    const unsigned& id) : 
 FaceGeometry<ELEMENT>(), FaceElement()
  { 

   // Initialise
   Poisson_sing_el_pt=0;

   // Let the bulk element build the FaceElement, i.e. setup the pointers 
   // to its nodes (by referring to the appropriate nodes in the bulk
   // element), etc.
   bulk_el_pt->build_face_element(face_index,this);
 
#ifdef PARANOID
   {
    //Check that the element is not a refineable 3d element
    ELEMENT* elem_pt = dynamic_cast<ELEMENT*>(bulk_el_pt);
    //If it's three-d
    if(elem_pt->dim()==3)
     {
      //Is it refineable
      RefineableElement* ref_el_pt=dynamic_cast<RefineableElement*>(elem_pt);
      if(ref_el_pt!=0)
       {
        if (this->has_hanging_nodes())
         {
          throw OomphLibError(
           "This face element will not work correctly if nodes are hanging\n",
           OOMPH_CURRENT_FUNCTION,
           OOMPH_EXCEPTION_LOCATION);
         }
       }
     }
   }
#endif   

   // Extract the dimension of the problem from the dimension of 
   // the first node
   Dim = this->node_pt(0)->ndim();

   //Set up U_index_poisson. Initialise to zero, which probably won't change
   //in most cases, oh well, the price we pay for generality
   U_index_poisson = 0;

   //Cast to the appropriate PoissonEquation so that we can
   //find the index at which the variable is stored
   //We assume that the dimension of the full problem is the same
   //as the dimension of the node, if this is not the case you will have
   //to write custom elements, sorry
   switch(Dim)
    {
     //One dimensional problem
    case 1:
    {
     PoissonEquations<1>* eqn_pt = 
      dynamic_cast<PoissonEquations<1>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from PoissonEquations.";
       error_string += 
        "Nodes are one dimensional, but cannot cast the bulk element to\n";
       error_string += "PoissonEquations<1>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
     //Otherwise read out the value
     else
      {
       //Read the index from the (cast) bulk element
       U_index_poisson = eqn_pt->u_index_poisson();
      }
    }
    break;
    
    //Two dimensional problem
    case 2:
    {
     PoissonEquations<2>* eqn_pt = 
      dynamic_cast<PoissonEquations<2>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from PoissonEquations.";
       error_string += 
        "Nodes are two dimensional, but cannot cast the bulk element to\n";
       error_string += "PoissonEquations<2>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
     else
      {
       //Read the index from the (cast) bulk element.
       U_index_poisson = eqn_pt->u_index_poisson();
      }
    }
    break;
    
    //Three dimensional problem
    case 3:
    {
     PoissonEquations<3>* eqn_pt = 
      dynamic_cast<PoissonEquations<3>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from PoissonEquations.";
       error_string += 
        "Nodes are three dimensional, but cannot cast the bulk element to\n";
       error_string += "PoissonEquations<3>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
       
      }
     else
      {
       //Read the index from the (cast) bulk element.
       U_index_poisson = eqn_pt->u_index_poisson();
      }
    }
    break;

    //Any other case is an error
    default:
     std::ostringstream error_stream; 
     error_stream <<  "Dimension of node is " << Dim 
                  << ". It should be 1,2, or 3!" << std::endl;
     
     throw OomphLibError(error_stream.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
     break;
    }



   // Where is the extra dof representing the Lagrange multiplier stored?
   // Initially store number of values stored right now
   unsigned nnod=nnode();
   Lambda_index.resize(nnod);
   for (unsigned j=0;j<nnod;j++)
    {
     Lambda_index[j]=node_pt(j)->nvalue();
    }

   // Make space for one Lagrange multiplier
   Vector<unsigned> n_additional_values(nnod,1);
   this->add_additional_values(n_additional_values,id);


   // Now check if we've added a new value. If so, that's
   // the Lagrange multiplier; it not, it was already stored
   // there so the actual index is one less
   for (unsigned j=0;j<nnod;j++)
    {
     if (Lambda_index[j]==node_pt(j)->nvalue())
      {
       Lambda_index[j]--;
      }
    }

  }


//===========================================================================
/// Compute the element's residual vector and the Jacobian matrix.
//===========================================================================
 template<class ELEMENT>
  void PoissonWithSingularityBCFaceElement<ELEMENT>::
  fill_in_generic_residual_contribution_poisson_sing(
   Vector<double> &residuals, DenseMatrix<double> &jacobian, 
   const unsigned& flag)
  {

   // hierher this is all for 1D; keep around until DIM-dimensional 
   // version works
   if (this->dim()==0)
    {
     
     // Compute various quantities
     Vector<double> x(1);
     x[0]=node_pt(0)->x(0);
     double u_sing=Poisson_sing_el_pt->singular_fct(x);
     double lambda=node_pt(0)->value(Lambda_index[0]);
     double u_fe=node_pt(0)->value(U_index_poisson);
     double u_bc=Nodal_boundary_value[0];
     
     // Various local equation numbers
     int local_eqn_lagr=nodal_local_eqn(0,Lambda_index[0]);
     int local_eqn_u_fe=nodal_local_eqn(0,U_index_poisson);
     
     // Get flux (=gradient) vector in the bulk element. We're
     // making the fe solution regular by setting this to zero!
     Vector<double> s_flux(1); // hierher local coordinate where flux is to be
     // evaluated should get passed in, together with normal
     s_flux[0]=-1.0;
     Vector<double> flux(1);
     ELEMENT* bulk_el_pt=dynamic_cast<ELEMENT*>(bulk_element_pt());
     bulk_el_pt->get_flux(s_flux,flux);
     
     // Derivatives of flux (in bulk element) w.r.t. to nodal unknowns
     // in bulk element
     unsigned nnod_bulk=bulk_el_pt->nnode();
     Vector<Vector<double> > dflux_dnodal_u(1); // hierher loop properly
     dflux_dnodal_u[0].resize(nnod_bulk);
     bulk_el_pt->get_dflux_dnodal_u(s_flux,dflux_dnodal_u);
     
     
#ifdef PARANOID
     // Lagrange multiplier active but u_fe pinned won't work!
     if ( (local_eqn_lagr>=0) && (local_eqn_u_fe<0) )
      {
       throw OomphLibError(
        "Lagrange multiplier active but u_fe pinned won't work!",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     
     
     // Lagrange multiplier for BC residual: It's determined by enforcing
     // that u_fe + C u_sing = u_bc
     if (local_eqn_lagr>=0)
      {
       residuals[local_eqn_lagr]+=((u_fe+u_sing)-u_bc); 
       if (flag==1)
        {
         if (local_eqn_u_fe>=0) jacobian(local_eqn_lagr,local_eqn_u_fe)=1.0;
        }
      }
     
     // Contribution to bulk equation: Lagrange multiplier
     if (local_eqn_u_fe>=0)
      {
       residuals[local_eqn_u_fe]+=lambda;
       if (flag==1)
        {
         if (local_eqn_lagr>=0) jacobian(local_eqn_u_fe,local_eqn_lagr)+=1.0;
        }
      }
    }
   else
    {
     //Find out how many nodes there are
     const unsigned n_node = nnode();
     
     //Set up memory for the shape and test functions
     Shape psi(n_node), test(n_node);
     
     //Set the value of Nintpt
     const unsigned n_intpt = integral_pt()->nweight();
     
     //Set the Vector to hold local coordinates
     Vector<double> s(Dim-1);
     
     
     //Loop over the integration points
     //--------------------------------
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       
       //Assign values of s
       for(unsigned i=0;i<(Dim-1);i++) 
        {
         s[i] = integral_pt()->knot(ipt,i);
        }
       
       //Get the integral weight
       double w = integral_pt()->weight(ipt);
       
       //Find the shape and test functions and return the Jacobian
       //of the mapping
       double J = shape_and_test(s,psi,test);
       
       //Premultiply the weights and the Jacobian
       double W = w*J;
       
       //Calculate stuff at integration point
       Vector<double> interpolated_x(Dim,0.0);
       double u_fe=0.0;
       double u_bc=0.0;
       double lambda=0.0;
       for(unsigned l=0;l<n_node;l++) 
        {         
         u_fe+=this->nodal_value(l,U_index_poisson)*psi[l];
         u_bc+=Nodal_boundary_value[l]*psi[l];
         lambda+=this->nodal_value(l,Lambda_index[l])*psi[l];
         for(unsigned i=0;i<Dim;i++)
          {
           interpolated_x[i] += this->nodal_position(l,i)*psi[l];
          }
        }
       
       // Stuff related to singular fct
       double u_sing=Poisson_sing_el_pt->singular_fct(interpolated_x);  
       double u_sing_unscaled=
        Poisson_sing_el_pt->unscaled_singular_fct(interpolated_x);
       
       
       //Now add to the appropriate equations
       
       //Loop over the test functions
       for(unsigned l=0;l<n_node;l++)
        {
         int local_eqn_lagr=nodal_local_eqn(l,Lambda_index[l]);
         int local_eqn_u_fe=nodal_local_eqn(l,U_index_poisson);
         int local_eqn_c=external_local_eqn(C_external_data_index,
                                            C_external_data_value_index);
         
#ifdef PARANOID
         // Lagrange multiplier active but u_fe pinned won't work!
         if ( (local_eqn_lagr>=0) && (local_eqn_u_fe<0) )
          {
           throw OomphLibError(
            "Lagrange multiplier active but u_fe pinned won't work!",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
          }
#endif
     
         
         // Lagrange multiplier for BC residual: It's determined by enforcing
         // that u_fe + C u_sing = u_bc
         if(local_eqn_lagr >= 0)
          {
           residuals[local_eqn_lagr] += ((u_fe+u_sing)-u_bc)*test[l]*W;
           
           // Jacobian?
           if (flag==1)
            {
             for(unsigned l2=0;l2<n_node;l2++)
              {
               int local_unknown_u_fe=nodal_local_eqn(l2,U_index_poisson);
               if (local_unknown_u_fe>=0)
                {
                 jacobian(local_eqn_lagr,local_unknown_u_fe)+=psi[l2]*test[l]*W;
                }
              }
             
             // Deriv. w.r.t. amplitude is simply the unscaled singular fct.
             if (local_eqn_c>=0)
              {
               jacobian(local_eqn_lagr,local_eqn_c)+=u_sing_unscaled*test[l]*W;
              }
            }
          }
         
         // Contribution of Lagrange multiplier to bulk eqn:
         if (local_eqn_u_fe>=0)
          {
           residuals[local_eqn_u_fe]+=lambda*test[l]*W;
           if (flag==1)
            {
             for(unsigned l2=0;l2<n_node;l2++)
              {
               int local_unknown_lambda=nodal_local_eqn(l2,Lambda_index[l2]);
               if (local_unknown_lambda>=0)
                {
                 jacobian(local_eqn_u_fe,local_unknown_lambda)+=
                  psi[l2]*test[l]*W;
                }
              }
            }
          }

        }
      }
    }

  }

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//====================================================================
/// New class. Mainly overloads output-related functions to add
/// "singular function" (which is assumed to satisfy the Laplace
/// equation; therefore no change to the governing (bulk) equations) 
/// to the FE solution. 
//====================================================================
template<unsigned DIM, unsigned NNODE_1D>
class MyQPoissonElement : public virtual QPoissonElement<DIM,NNODE_1D>
{

public:

 /// Constructor
 MyQPoissonElement() : Poisson_sing_el_pt(0)
  {}

 /// \short Return FE representation of function value u_poisson(s) 
 /// plus scaled singular fct (if provided) at local coordinate s
 inline double interpolated_u_poisson(const Vector<double> &s) const
  {
   double u_fe=QPoissonElement<DIM,NNODE_1D>::interpolated_u_poisson(s);
   if (Poisson_sing_el_pt!=0)
    {     
     Vector<double> x(DIM);
     for(unsigned i=0;i<DIM;i++) 
      {
       x[i]=this->interpolated_x(s,i);
      }
     u_fe+=Poisson_sing_el_pt->singular_fct(x);
    }
   return u_fe;
  } 


 /// Output with various contributions
 void  output_with_various_contributions(std::ostream &outfile, 
                                         const unsigned &nplot)
  {
   //Vector of local coordinates
   Vector<double> s(DIM);
   
   // Tecplot header info
   outfile << this->tecplot_zone_string(nplot);
   
   // Loop over plot points
   unsigned num_plot_points=this->nplot_points(nplot);
   for (unsigned iplot=0;iplot<num_plot_points;iplot++)
    {
     // Get local coordinates of plot point
     this->get_s_plot(iplot,nplot,s);
     
     Vector<double> x(DIM);
     for(unsigned i=0;i<DIM;i++) 
      {
       x[i]=this->interpolated_x(s,i);
       outfile << x[i] << " ";
      }
     double u_sing=0.0;
     if (Poisson_sing_el_pt!=0)
      {
       u_sing=Poisson_sing_el_pt->singular_fct(x);
      }
     outfile << this->interpolated_u_poisson(s) << " "
             << QPoissonElement<DIM,NNODE_1D>::interpolated_u_poisson(s) << " "
             << u_sing << " "
             << std::endl;   
    }
   
   // Write tecplot footer (e.g. FE connectivity lists)
   this->write_tecplot_zone_footer(outfile,nplot);
   
  }

 /// Pointer to element that stores singular fct
 TemplateFreeScalableSingularityForPoissonElement*& poisson_sing_el_pt()
  {
   return Poisson_sing_el_pt;
  }
 
private:

 /// Pointer to element that stores singular fct
 TemplateFreeScalableSingularityForPoissonElement* Poisson_sing_el_pt;
 
};


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the MyQPoissonElement elements: The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class FaceGeometry<MyQPoissonElement<DIM,NNODE_1D> >: 
 public virtual QElement<DIM-1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : QElement<DIM-1,NNODE_1D>() {}

};

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the 1D MyQPoissonElement elements: Point elements
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<MyQPoissonElement<1,NNODE_1D> >: 
 public virtual PointElement
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional QElement
 FaceGeometry() : PointElement() {}

};



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

// hierher really need to tidy this up! Should only need one class 
// for T and Q

//====================================================================
/// New class. Mainly overloads output-related functions to add
/// "singular function" (which is assumed to satisfy the Laplace
/// equation; therefore no change to the governing (bulk) equations) 
/// to the FE solution. 
//====================================================================
template<unsigned DIM, unsigned NNODE_1D>
class MyTPoissonElement : public virtual TPoissonElement<DIM,NNODE_1D>
{

public:

 /// Constructor
 MyTPoissonElement() : Poisson_sing_el_pt(0)
  {}

 /// \short Return FE representation of function value u_poisson(s) 
 /// plus scaled singular fct (if provided) at local coordinate s
 inline double interpolated_u_poisson(const Vector<double> &s) const
  {
   double u_fe=TPoissonElement<DIM,NNODE_1D>::interpolated_u_poisson(s);
   if (Poisson_sing_el_pt!=0)
    {     
     Vector<double> x(DIM);
     for(unsigned i=0;i<DIM;i++) 
      {
       x[i]=this->interpolated_x(s,i);
      }
     u_fe+=Poisson_sing_el_pt->singular_fct(x);
    }
   return u_fe;
  } 


 /// Output with various contributions
 void  output_with_various_contributions(std::ostream &outfile, 
                                         const unsigned &nplot)
  {
   //Vector of local coordinates
   Vector<double> s(DIM);
   
   // Tecplot header info
   outfile << this->tecplot_zone_string(nplot);
   
   // Loop over plot points
   unsigned num_plot_points=this->nplot_points(nplot);
   for (unsigned iplot=0;iplot<num_plot_points;iplot++)
    {
     // Get local coordinates of plot point
     this->get_s_plot(iplot,nplot,s);
     
     Vector<double> x(DIM);
     for(unsigned i=0;i<DIM;i++) 
      {
       x[i]=this->interpolated_x(s,i);
       outfile << x[i] << " ";
      }
     double u_sing=0.0;
     if (Poisson_sing_el_pt!=0)
      {
       u_sing=Poisson_sing_el_pt->singular_fct(x);
      }
     outfile << this->interpolated_u_poisson(s) << " "
             << TPoissonElement<DIM,NNODE_1D>::interpolated_u_poisson(s) << " "
             << u_sing << " "
             << std::endl;   
    }
   
   // Write tecplot footer (e.g. FE connectivity lists)
   this->write_tecplot_zone_footer(outfile,nplot);
   
  }

 /// Pointer to element that stores singular fct
 TemplateFreeScalableSingularityForPoissonElement*& poisson_sing_el_pt()
  {
   return Poisson_sing_el_pt;
  }

 
// hierher hmmm... not quite what we want because it seems to suggest that
// the fe solution is very steep near the singularity again... We just
// want to "smooth out" the jump

 /* /// Get 'flux' for Z2 error recovery:  Standard flux.from Poisson equations */
 /* //void get_Z2_flux(const Vector<double>& s, Vector<double>& flux) */
 /* void get_Z2_flux(const Vector<double>& s, Vector<double>& flux) */
 /* { */
 /*  // Get flux of FE solution */
 /*  TPoissonElement<DIM,NNODE_1D>::get_flux(s,flux); */
  
 /*  // Do we have to add the singular flux? */
 /*  if (Poisson_sing_el_pt!=0) */
 /*   { */
 /*    // Where are we? */
 /*    unsigned n=this->dim(); */
 /*    Vector<double> interpolated_x(n,0.0);  */
    
 /*    // Get shape fct */
 /*    unsigned n_node = this->nnode(); */
 /*    Shape psi(n_node); */
 /*    this->shape(s,psi); */
    
 /*    // Assemble */
 /*    for(unsigned l=0;l<n_node;l++)  */
 /*     {    */
 /*      for(unsigned i=0;i<n;i++) */
 /*       { */
 /*        interpolated_x[i] += this->nodal_position(l,i)*psi[l]; */
 /*       } */
 /*     } */
    
 /*    // Get flux (gradient) of singular fct */
 /*    Vector<double> grad_u_sing= */
 /*     Poisson_sing_el_pt->gradient_of_singular_fct(interpolated_x);  */
    
 /*    // Add 'em */
 /*    for(unsigned i=0;i<n;i++) */
 /*     { */
 /*      flux[i]+=grad_u_sing[0]; */
 /*     } */
 /*   } */
 /* } */


private:

 /// Pointer to element that stores singular fct
 TemplateFreeScalableSingularityForPoissonElement* Poisson_sing_el_pt;
 
};


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the MyTPoissonElement elements: The spatial 
/// dimension of the face elements is one lower than that of the
/// bulk element but they have the same number of points
/// along their 1D edges.
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class FaceGeometry<MyTPoissonElement<DIM,NNODE_1D> >: 
 public virtual TElement<DIM-1,NNODE_1D>
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional TElement
 FaceGeometry() : TElement<DIM-1,NNODE_1D>() {}

};

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=======================================================================
/// Face geometry for the 1D MyTPoissonElement elements: Point elements
//=======================================================================
template<unsigned NNODE_1D>
class FaceGeometry<MyTPoissonElement<1,NNODE_1D> >: 
 public virtual PointElement
{

  public:
 
 /// \short Constructor: Call the constructor for the
 /// appropriate lower-dimensional TElement
 FaceGeometry() : PointElement() {}

};


}

#endif
